\chapter{Implementation}\label{ch:implementation}
The goal of this chapter is to provide a guide on how to reproduce the experiments.
This includes a tutorial on how to get the project running but also a brief high-level overview of the code to facilitate easy retrieval of requested information.


\section{Setup}
This section deals with the topic of setting up this project and to navigate through it.
It is intended to readers who want to run the experiments themselves or help to dig into the exact implementations.

\subsection{Environment}
This project was developed using pyenv and pip.
Pyenv was selected due to its ability to create a virtual Python environment while still utilizing pip as the native package manager, distinguishing it from alternatives like anaconda.
\newline

The project's requirements are outlined in the requirements.txt file.
The desired Python version is specified in the .python-version file, generated by pyenv.
To install the requirements, execute the following commands in the project's top directory within a Bash environment:

\begin{center}
    \begin{lstlisting}[language=bash]
#!/bin/bash
pyenv install 3.11
pyenv local 3.11
source venv/bin/activate
pip install -r requirements.txt
    \end{lstlisting}
\end{center}

\subsection{Code Structure}
The project consists of three primary folders: \textit{src/shared}, \textit{src/experiments}, and \textit{tests}.
The \textit{tests} folder contains code dedicated to programmatic validation of the implementations, primarily comprising unit tests.
The \textit{src/shared} folder contains code that is shared among all experiments conducted in the project.
This includes implementations for streaming and collision, among others.
Lastly, the \textit{src/experiments} folder contains experiment-specific code.


\section{Probability Density Function}
The probability density function is modelled as a \textit{numpy} array with three dimensions, namely: channels, x-direction and y-direction in this order.
While the number of channels allways has to be exactly 9, the x and y dimensions may vary in size and are independent of each other.
These constraints to the probability density function are assumed by all implemented functions and have to hold at all time.
\newline

The Probability density function follows the scheme described in \cref{sec:lattice-bolzmann-scheme}.
While the grid in \cref{fig:bte-scheme} resembles the second and third dimension of the PDF, the channels can be imagined as a third dimension on the grid.
Each channel resembles one direction of moving as shown in the left part of \cref{fig:bte-scheme}.
The indices of the channels are in line with the indices of the arrows in the graphic.


\section{Main Routine}\label{sec:main-routine}
The main routine may be seen as a function that is repeated until the experiment is over.
It consists of several operators that stay the same in each experiment.
For some experiments, not all operators are used or for example the \textit{bounce-back} is only applied to certain walls.
\textbf{The order of the operators always stays the same and is crucial for a successive experiment}.
All possible operators are listed below:
\begin{enumerate}
    \item collision - handles colliding particles in the simulation
    \item sliding - applies a steady velocity to on side
    \item bounce back - bounces particles back into from certain walls
    \item stream - moves all particles in their designated directions
\end{enumerate}

An interested reader may find the exact implementation in \textit{src/shared/boltzmann.py}.
As it is redundant and maybe not inline with the exact implementation, there won't be code examples at this point.
However, it is to mention that all examples follow strictly the formulas explained in \cref{ch:methods}.


\section{Parallelization}\label{sec:parallelization}
The last experiment \cref{sec:sliding-lit} utilizes the \textit{mpi4py} package to parallelize its run.
The MPI interface allows spreading the array of the probability density function over several processes.
Each process then determines the result one iteration of the main routine (described in \cref{sec:main-routine}) for its subarray.
Afterward, the results are combined by shifting the boundaries of each subarray, as shown in the following example.
\newline

A right shift for process 4 works as following, if assuming that there are the processes 3, 4 and 5.
Process 4 would receive the right side from process 3 and save it in its left side.
Simultaneously, process 4 would send its right side to process 5.
This is repeated for all processes and the direction up, down, left and right.
The exact topology of the processes may vary and is determined by MPI itself.
